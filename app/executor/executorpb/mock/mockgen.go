// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/cox96de/runner/app/executor/executorpb (interfaces: ExecutorClient)
//
// Generated by this command:
//
//	mockgen -destination mock/mockgen.go -typed -package mock . ExecutorClient
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	executorpb "github.com/cox96de/runner/app/executor/executorpb"
	gomock "go.uber.org/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockExecutorClient is a mock of ExecutorClient interface.
type MockExecutorClient struct {
	ctrl     *gomock.Controller
	recorder *MockExecutorClientMockRecorder
	isgomock struct{}
}

// MockExecutorClientMockRecorder is the mock recorder for MockExecutorClient.
type MockExecutorClientMockRecorder struct {
	mock *MockExecutorClient
}

// NewMockExecutorClient creates a new mock instance.
func NewMockExecutorClient(ctrl *gomock.Controller) *MockExecutorClient {
	mock := &MockExecutorClient{ctrl: ctrl}
	mock.recorder = &MockExecutorClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExecutorClient) EXPECT() *MockExecutorClientMockRecorder {
	return m.recorder
}

// Environment mocks base method.
func (m *MockExecutorClient) Environment(ctx context.Context, in *executorpb.EnvironmentRequest, opts ...grpc.CallOption) (*executorpb.EnvironmentResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Environment", varargs...)
	ret0, _ := ret[0].(*executorpb.EnvironmentResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Environment indicates an expected call of Environment.
func (mr *MockExecutorClientMockRecorder) Environment(ctx, in any, opts ...any) *MockExecutorClientEnvironmentCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Environment", reflect.TypeOf((*MockExecutorClient)(nil).Environment), varargs...)
	return &MockExecutorClientEnvironmentCall{Call: call}
}

// MockExecutorClientEnvironmentCall wrap *gomock.Call
type MockExecutorClientEnvironmentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockExecutorClientEnvironmentCall) Return(arg0 *executorpb.EnvironmentResponse, arg1 error) *MockExecutorClientEnvironmentCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockExecutorClientEnvironmentCall) Do(f func(context.Context, *executorpb.EnvironmentRequest, ...grpc.CallOption) (*executorpb.EnvironmentResponse, error)) *MockExecutorClientEnvironmentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockExecutorClientEnvironmentCall) DoAndReturn(f func(context.Context, *executorpb.EnvironmentRequest, ...grpc.CallOption) (*executorpb.EnvironmentResponse, error)) *MockExecutorClientEnvironmentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCommandLog mocks base method.
func (m *MockExecutorClient) GetCommandLog(ctx context.Context, in *executorpb.GetCommandLogRequest, opts ...grpc.CallOption) (executorpb.Executor_GetCommandLogClient, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetCommandLog", varargs...)
	ret0, _ := ret[0].(executorpb.Executor_GetCommandLogClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCommandLog indicates an expected call of GetCommandLog.
func (mr *MockExecutorClientMockRecorder) GetCommandLog(ctx, in any, opts ...any) *MockExecutorClientGetCommandLogCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommandLog", reflect.TypeOf((*MockExecutorClient)(nil).GetCommandLog), varargs...)
	return &MockExecutorClientGetCommandLogCall{Call: call}
}

// MockExecutorClientGetCommandLogCall wrap *gomock.Call
type MockExecutorClientGetCommandLogCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockExecutorClientGetCommandLogCall) Return(arg0 executorpb.Executor_GetCommandLogClient, arg1 error) *MockExecutorClientGetCommandLogCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockExecutorClientGetCommandLogCall) Do(f func(context.Context, *executorpb.GetCommandLogRequest, ...grpc.CallOption) (executorpb.Executor_GetCommandLogClient, error)) *MockExecutorClientGetCommandLogCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockExecutorClientGetCommandLogCall) DoAndReturn(f func(context.Context, *executorpb.GetCommandLogRequest, ...grpc.CallOption) (executorpb.Executor_GetCommandLogClient, error)) *MockExecutorClientGetCommandLogCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRuntimeInfo mocks base method.
func (m *MockExecutorClient) GetRuntimeInfo(ctx context.Context, in *executorpb.GetRuntimeInfoRequest, opts ...grpc.CallOption) (*executorpb.GetRuntimeInfoResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetRuntimeInfo", varargs...)
	ret0, _ := ret[0].(*executorpb.GetRuntimeInfoResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRuntimeInfo indicates an expected call of GetRuntimeInfo.
func (mr *MockExecutorClientMockRecorder) GetRuntimeInfo(ctx, in any, opts ...any) *MockExecutorClientGetRuntimeInfoCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRuntimeInfo", reflect.TypeOf((*MockExecutorClient)(nil).GetRuntimeInfo), varargs...)
	return &MockExecutorClientGetRuntimeInfoCall{Call: call}
}

// MockExecutorClientGetRuntimeInfoCall wrap *gomock.Call
type MockExecutorClientGetRuntimeInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockExecutorClientGetRuntimeInfoCall) Return(arg0 *executorpb.GetRuntimeInfoResponse, arg1 error) *MockExecutorClientGetRuntimeInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockExecutorClientGetRuntimeInfoCall) Do(f func(context.Context, *executorpb.GetRuntimeInfoRequest, ...grpc.CallOption) (*executorpb.GetRuntimeInfoResponse, error)) *MockExecutorClientGetRuntimeInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockExecutorClientGetRuntimeInfoCall) DoAndReturn(f func(context.Context, *executorpb.GetRuntimeInfoRequest, ...grpc.CallOption) (*executorpb.GetRuntimeInfoResponse, error)) *MockExecutorClientGetRuntimeInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Ping mocks base method.
func (m *MockExecutorClient) Ping(ctx context.Context, in *executorpb.PingRequest, opts ...grpc.CallOption) (*executorpb.PingResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Ping", varargs...)
	ret0, _ := ret[0].(*executorpb.PingResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Ping indicates an expected call of Ping.
func (mr *MockExecutorClientMockRecorder) Ping(ctx, in any, opts ...any) *MockExecutorClientPingCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockExecutorClient)(nil).Ping), varargs...)
	return &MockExecutorClientPingCall{Call: call}
}

// MockExecutorClientPingCall wrap *gomock.Call
type MockExecutorClientPingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockExecutorClientPingCall) Return(arg0 *executorpb.PingResponse, arg1 error) *MockExecutorClientPingCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockExecutorClientPingCall) Do(f func(context.Context, *executorpb.PingRequest, ...grpc.CallOption) (*executorpb.PingResponse, error)) *MockExecutorClientPingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockExecutorClientPingCall) DoAndReturn(f func(context.Context, *executorpb.PingRequest, ...grpc.CallOption) (*executorpb.PingResponse, error)) *MockExecutorClientPingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StartCommand mocks base method.
func (m *MockExecutorClient) StartCommand(ctx context.Context, in *executorpb.StartCommandRequest, opts ...grpc.CallOption) (*executorpb.StartCommandResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StartCommand", varargs...)
	ret0, _ := ret[0].(*executorpb.StartCommandResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StartCommand indicates an expected call of StartCommand.
func (mr *MockExecutorClientMockRecorder) StartCommand(ctx, in any, opts ...any) *MockExecutorClientStartCommandCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartCommand", reflect.TypeOf((*MockExecutorClient)(nil).StartCommand), varargs...)
	return &MockExecutorClientStartCommandCall{Call: call}
}

// MockExecutorClientStartCommandCall wrap *gomock.Call
type MockExecutorClientStartCommandCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockExecutorClientStartCommandCall) Return(arg0 *executorpb.StartCommandResponse, arg1 error) *MockExecutorClientStartCommandCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockExecutorClientStartCommandCall) Do(f func(context.Context, *executorpb.StartCommandRequest, ...grpc.CallOption) (*executorpb.StartCommandResponse, error)) *MockExecutorClientStartCommandCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockExecutorClientStartCommandCall) DoAndReturn(f func(context.Context, *executorpb.StartCommandRequest, ...grpc.CallOption) (*executorpb.StartCommandResponse, error)) *MockExecutorClientStartCommandCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// WaitCommand mocks base method.
func (m *MockExecutorClient) WaitCommand(ctx context.Context, in *executorpb.WaitCommandRequest, opts ...grpc.CallOption) (*executorpb.WaitCommandResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WaitCommand", varargs...)
	ret0, _ := ret[0].(*executorpb.WaitCommandResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WaitCommand indicates an expected call of WaitCommand.
func (mr *MockExecutorClientMockRecorder) WaitCommand(ctx, in any, opts ...any) *MockExecutorClientWaitCommandCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitCommand", reflect.TypeOf((*MockExecutorClient)(nil).WaitCommand), varargs...)
	return &MockExecutorClientWaitCommandCall{Call: call}
}

// MockExecutorClientWaitCommandCall wrap *gomock.Call
type MockExecutorClientWaitCommandCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockExecutorClientWaitCommandCall) Return(arg0 *executorpb.WaitCommandResponse, arg1 error) *MockExecutorClientWaitCommandCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockExecutorClientWaitCommandCall) Do(f func(context.Context, *executorpb.WaitCommandRequest, ...grpc.CallOption) (*executorpb.WaitCommandResponse, error)) *MockExecutorClientWaitCommandCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockExecutorClientWaitCommandCall) DoAndReturn(f func(context.Context, *executorpb.WaitCommandRequest, ...grpc.CallOption) (*executorpb.WaitCommandResponse, error)) *MockExecutorClientWaitCommandCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
